/**
 * @brief Support for Gaussian filters in relief processing.
 *
 * @file GaussianFilter.cpp
 * @afstoputhor Steve Knipmeyer
 * @date 2018-09-03
 */
#define _USE_MATH_DEFINES
#include <iostream>
#include <cmath>
#include <iomanip>
#include <assert.h>

#include "ModelRelief.h"
#include "GaussianFilter.h"
#include "StopWatch.h"

using namespace std;

namespace ModelRelief {

//-------------------------------------------------------------------------------------------------//
//                                      Public                                                     //
//-------------------------------------------------------------------------------------------------//

/**
 * @brief Construct a new Gaussian Filter instance.
 *
 * @param image NumPy image.
 * @param mask NumPy mask. Only unmasked image elements are included in the filter.
 * @param sigma Standard deviation.
 */
GaussianFilter::GaussianFilter(NPDoubleArray& image, NPDoubleArray& mask, double sigma) : m_image(image), m_mask(mask), m_pDefaultKernel(new GaussianKernel(sigma))
{
    m_sigma = sigma;
    InitializeNative(image, mask);
}

/**
 * @brief Destroy the Gaussian Filter instance.
 *
 */
GaussianFilter::~GaussianFilter()
{
}

/**
 * @brief GaussianBlur
 * http://blog.ivank.net/fastest-gaussian-blur.html#results
 * Algorithm 1
 *
 * @param pSource Source image.
 * @param pResult Result image.
 * @param width Image width.
 * @param height Image Height.
 * @param sigma Standard deviation.
 * @return NPDoubleArray&
 *
 */
void GaussianFilter::GaussianBlur1 (double* pSource, double* pResult, int width, int height, double sigma)
{
    // significant radius
    int radius = ceil(sigma * 2.57);               
    std::cout << "radius = " << radius << std::endl;

    for (int i = 0; i < height; i++)
        for (int j = 0; j < width; j++) 
        {
            double value = 0;
            double weightSum = 0;
            for (int iy = i - radius; iy < i + radius + 1; iy++)
                for (int ix = j - radius; ix < j + radius + 1; ix++) 
                {
                    int x = min(width - 1, max(0, ix));
                    int y = min(height - 1, max(0, iy));

                    double distanceSquared = (ix - j)*(ix - j) + (iy - i)*(iy - i);
                    double weight = exp(-distanceSquared / (2 * sigma*sigma)) / (M_PI * 2 * sigma*sigma);
                    value += pSource[y*width + x] * weight;  weightSum += weight;
                }
            pResult[i*width + j] = round(value / weightSum);
        }
}

/**
 * @brief Calculate the filter.
 *
 * @return NPDoubleArray&
 *
 */
NPDoubleArray GaussianFilter::Calculate()
{
    // allocate output buffer
    NPDoubleArray result = NPDoubleArray(m_columns * m_rows);
    py::buffer_info resultBuffer = result.request();
    double *pResult = (double *)resultBuffer.ptr;

#if true
    GaussianKernel kernel(m_sigma);
    for (int row = 0; row < m_rows; row++)
    {
        for (int column = 0; column < m_columns; column++)
        {
            pResult[row*m_columns + column] = ApplyKernel(kernel, row, column);
        }
    }        
#else
    GaussianBlur1(m_pImage, pResult, m_columns, m_rows, m_sigma);
#endif

    // reshape result to have same shape as input
    result.resize({ m_columns, m_rows});

    return result;
}

//-------------------------------------------------------------------------------------------------//
//                                      Private                                                    //
//-------------------------------------------------------------------------------------------------//

/**
 * @brief Convert the NumPy array and mask references to pointers.
 *
 * @param image NumPy image.
 * @param mask NumPy composite mask. Only unmasked image elements are included in the filter.
 */
void GaussianFilter::InitializeNative(NPDoubleArray& image, NPDoubleArray& mask)
{
    // Image
    py::buffer_info buffer = image.request();
    m_pImage = (double *)buffer.ptr;
    m_rows = static_cast<int>(buffer.shape[0]);
    m_columns = static_cast<int>(buffer.shape[1]);

    // Mask
    buffer = mask.request();
    m_pMask = (double *)buffer.ptr;
}

/**
 * @brief Returns the image element offset from the given row and column.
 *        Elements outside the image bounds are generated by reflection.
 *
 * @param row Image row.
 * @param column Image column.
 * @param xOffset X offset (from column).
 * @param yOffset Y offset (from row).
 * @return double Image element corresponding to [row + xOffset, column + yOffset].
 *
 */
double GaussianFilter::GetOffsetImageElement(int row, int column, int xOffset, int yOffset)
{
    int targetRow    = row + yOffset;
    int targetColumn = column + xOffset;

    // column bounds check
    if (targetColumn < 0)
        targetColumn = abs(long(column + xOffset));
    if (targetColumn > (m_columns - 1))
        targetColumn = (m_columns - 1) - ((column + xOffset) - (m_columns - 1));

    // row bounds check
    if (targetRow < 0)
        targetRow = abs(row + yOffset);
    if (targetRow > (m_rows - 1))
        targetRow = (m_rows - 1) - ((row + yOffset) - (m_rows - 1));

    assert((targetRow >= 0) && (targetRow < m_rows));
    assert((targetColumn >= 0) && (targetColumn < m_columns));

    return m_pImage[targetRow*m_columns + targetColumn];
}

/**
 * @brief Apply the given kernel to an image element.
 *
 * @param kernel Gaussian kernel to apply.
 * @param row Row of image array.
 * @param column Column of image array.
 * @return double Kernel convolved with element neighborhood.
 *
 */
double GaussianFilter::ApplyKernel(GaussianKernel& kernel, int row, int column)
{
    double sum = 0.0;
    int kernelXLimit = kernel.XLimit();
    int kernelYLimit = kernel.YLimit();

     // iteration: row major for performance
    for (int kernelY = kernelYLimit; kernelY >= -kernelYLimit; kernelY--)
    {
        for (int kernelX = -kernelXLimit; kernelX <= kernelXLimit; kernelX++)
        {
            double imageElement = GetOffsetImageElement(row, column, kernelX, kernelY);
            sum += imageElement * kernel.Element(kernelX, kernelY);
        }
    }
 
    return sum;
}
}