// ------------------------------------------------------------------------//// ModelRelief                                                             ////                                                                         //// Copyright (c) <2012-2017> Steve Knipmeyer                               //// ------------------------------------------------------------------------//var MR;MR = MR || {};MR.shaderSource = MR.shaderSource || {}; MR.shaderSource["DepthBufferFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n\n// enable extensions (e.g. dFdx, dFdy)\n// #extension GL_OES_standard_derivatives : enable\n\n//#define MAXIMUMPRECISION\n#if defined(MAXIMUMPRECISION)\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n#endif\n\n#include <packing>\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\nuniform float       cameraNear;                 // near clipping plane\nuniform float       cameraFar;                  // far clipping plane\nuniform sampler2D   tDiffuse;                   // diffuse texture \nuniform sampler2D   tDepth;                     // depth texture\n\nvarying vec2 vUV;								// UV coordinates of vertex\nvarying vec3 vNormal;							// vertex normal\nvarying vec3 vWorldPosition;					// vertex world position\nvarying vec3 vViewPosition;						// vertex view position (flipped)\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/webgl.html\n// https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\n    float shift_right (float v, float amt) { \n        v = floor(v) + 0.5; \n        return floor(v / exp2(amt)); \n    }\n\n    float shift_left (float v, float amt) { \n        return floor(v * exp2(amt) + 0.5); \n    }\n\n    float mask_last (float v, float bits) { \n        return mod(v, shift_left(1.0, bits)); \n    }\n\n    float extract_bits (float num, float from, float to) { \n        from = floor(from + 0.5); to = floor(to + 0.5); \n        return mask_last(shift_right(num, from), to - from); \n    }\n\n    vec4 encode_float (float val) { \n        if (val == 0.0) \n            return vec4(0, 0, 0, 0); \n\n        float sign = val > 0.0 ? 0.0 : 1.0; \n        val = abs(val); \n        float exponent = floor(log2(val)); \n        float biased_exponent = exponent + 127.0; \n        float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \n        float t = biased_exponent / 2.0; \n        float last_bit_of_biased_exponent = fract(t) * 2.0; \n        float remaining_bits_of_biased_exponent = floor(t); \n        float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \n        float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \n        float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n        float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n        return vec4(byte4, byte3, byte2, byte1); \n    }\n\n/// <summary>\n///  Read depth from buffer.\n//   Adjusts back to world (orthographic) coordinates.\n//   N.B. normalized clip coordinates [0,1]\n/// </summary>\nfloat readDepth (sampler2D depthSampler, vec2 uvCoordinate) {\n\n    float fragCoordZ = texture2D(depthSampler, uvCoordinate).x;\n    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\n    // normalized clip coordinates\n    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n}\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n    vec3 normal = normalize(vNormal); \n    vec3 viewPosition = normalize(vViewPosition);\n\n    vec3 diffuse = texture2D(tDiffuse, vUV).rgb;\n\n//  float depth = readDepth(tDepth, vUV);\n    float depth = texture2D(tDepth, vUV).x;\n\n    gl_FragColor = encode_float(depth);\n\n\n#if defined (DEBUG)\n    // float constant\n    gl_FragColor = encode_float(3.141592653);\n\n    // solid color\n    gl_FragColor.rgb = diffuse;\n    gl_FragColor.a = 1.0; \n\n    // raw depth buffer\n    gl_FragColor = texture2D(tDepth, vUV);\n#endif\n}\n\n#if defined(NOOP)\n    vec3 packNormalToRGB( const in vec3 normal ) {\n        return normalize( normal ) * 0.5 + 0.5;\n    }\n\n    vec3 unpackRGBToNormal( const in vec3 rgb ) {\n        return 1.0 - 2.0 * rgb.xyz;\n    }\n\n    const float PackUpscale = 256. / 255.;\n    const float UnpackDownscale = 255. / 256.;\n    const vec3  PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n    const vec4  UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n    const float ShiftRight8 = 1. / 256.;\n\n    vec4 packDepthToRGBA( const in float v ) {\n\n        vec4 r = vec4( fract( v * PackFactors ), v );\n        r.yzw -= r.xyz * ShiftRight8;	\n        return r * PackUpscale;\n    }\n\n    float unpackRGBAToDepth( const in vec4 v ) {\n        return dot( v, UnpackFactors );\n    }\n\n    float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n        return ( viewZ + near ) / ( near - far );\n    }\n\n    float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n        return linearClipZ * ( near - far ) - near;\n    }\n\n    float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n        return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n    }\n\n    float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n        return ( near * far ) / ( ( far - near ) * invClipZ - far );\n    }\n#endif\n";
MR.shaderSource["DepthBufferVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n\n//#define MAXIMUMPRECISION\n#if defined(MAXIMUMPRECISION)\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n#endif\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nvarying vec2 vUV;							// UV coordinates of vertex\nvarying vec3 vNormal;						// vertex normal\nvarying vec3 vWorldPosition;				// vertex world position\nvarying vec3 vViewPosition;					// vertex view position (flipped)\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vUV = uv;\n\n	vec3 transformedNormal = normalMatrix * normal;\n	vNormal = normalize(transformedNormal);\n\n	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n	vWorldPosition = worldPosition.xyz;\n\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vViewPosition = -mvPosition.xyz;\n\n	gl_Position = projectionMatrix * mvPosition;\n}\n";
MR.shaderSource["MeshFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n\n// enable extensions (e.g. dFdx, dFdy)\n// #extension GL_OES_standard_derivatives : enable\n\n//#define MAXIMUMPRECISION\n#if defined(MAXIMUMPRECISION)\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n#endif\n\n#include <packing>\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\nuniform float       cameraNear;                 // near clipping plane\nuniform float       cameraFar;                  // far clipping plane\nuniform sampler2D   tDiffuse;                   // diffuse texture \nuniform sampler2D   tDepth;                     // depth texture\n\nvarying vec2 vUV;                               // UV coordinates of vertex\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/webgl.html\n// https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\n    float shift_right (float v, float amt) { \n        v = floor(v) + 0.5; \n        return floor(v / exp2(amt)); \n    }\n\n    float shift_left (float v, float amt) { \n        return floor(v * exp2(amt) + 0.5); \n    }\n\n    float mask_last (float v, float bits) { \n        return mod(v, shift_left(1.0, bits)); \n    }\n\n    float extract_bits (float num, float from, float to) { \n        from = floor(from + 0.5); to = floor(to + 0.5); \n        return mask_last(shift_right(num, from), to - from); \n    }\n\n    vec4 encode_float (float val) { \n        if (val == 0.0) \n            return vec4(0, 0, 0, 0); \n\n        float sign = val > 0.0 ? 0.0 : 1.0; \n        val = abs(val); \n        float exponent = floor(log2(val)); \n        float biased_exponent = exponent + 127.0; \n        float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \n        float t = biased_exponent / 2.0; \n        float last_bit_of_biased_exponent = fract(t) * 2.0; \n        float remaining_bits_of_biased_exponent = floor(t); \n        float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \n        float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \n        float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n        float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n        return vec4(byte4, byte3, byte2, byte1); \n    }\n\n/// <summary>\n///  Read depth from buffer.\n//   Adjusts back to world (orthographic) coordinates.\n//   N.B. normalized clip coordinates [0,1]\n/// </summary>\nfloat readDepth (sampler2D depthSampler, vec2 uvCoordinate) {\n\n    float fragCoordZ = texture2D(depthSampler, uvCoordinate).x;\n    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\n    // normalized clip coordinates\n    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n}\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n    gl_FragColor = texture2D(tDepth, vUV);\n\n#if defined (DEBUG)\n    // raw depth buffer\n    gl_FragColor = texture2D(tDepth, vUV);\n#endif\n}\n\n#if defined(NOOP)\n    vec3 packNormalToRGB( const in vec3 normal ) {\n        return normalize( normal ) * 0.5 + 0.5;\n    }\n\n    vec3 unpackRGBToNormal( const in vec3 rgb ) {\n        return 1.0 - 2.0 * rgb.xyz;\n    }\n\n    const float PackUpscale = 256. / 255.;\n    const float UnpackDownscale = 255. / 256.;\n    const vec3  PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n    const vec4  UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n    const float ShiftRight8 = 1. / 256.;\n\n    vec4 packDepthToRGBA( const in float v ) {\n\n        vec4 r = vec4( fract( v * PackFactors ), v );\n        r.yzw -= r.xyz * ShiftRight8;	\n        return r * PackUpscale;\n    }\n\n    float unpackRGBAToDepth( const in vec4 v ) {\n        return dot( v, UnpackFactors );\n    }\n\n    float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n        return ( viewZ + near ) / ( near - far );\n    }\n\n    float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n        return linearClipZ * ( near - far ) - near;\n    }\n\n    float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n        return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n    }\n\n    float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n        return ( near * far ) / ( ( far - near ) * invClipZ - far );\n    }\n#endif\n";
MR.shaderSource["MeshVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n\n//#define MAXIMUMPRECISION\n#if defined(MAXIMUMPRECISION)\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n#endif\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nuniform float       cameraNear;             // near clipping plane\nuniform float       cameraFar;              // far clipping plane\nuniform sampler2D   tDiffuse;               // RGBA float depth\nuniform sampler2D   tDepth;                 // depth texture\n\nvarying vec2 vUV;                           // UV coordinates of vertex\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n    vUV = uv;\n\n    // adjust Z position by depth\n    vec3 positionPrime = position;\n\n    float depth = texture2D(tDepth, vUV).x;\n    depth = depth * (cameraFar - cameraNear);\n    positionPrime.z = -depth;\n\n    vec4 mvPosition;\n    mvPosition = modelViewMatrix * vec4(positionPrime, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n";
MR.shaderSource["TemplateFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n#include <packing>\n\n// enable extensions (e.g. dFdx, dFdy)\n#extension GL_OES_standard_derivatives : enable\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\nuniform vec3        designColor;				// color\nuniform sampler2D   tDiffuse;                   // diffuse texture (not used)\nuniform sampler2D   tDepth;                     // depth texture\nuniform float       cameraNear;                 // near clipping plane\nuniform float       cameraFar;                  // far clipping plane\n\nvarying vec2 vUV;								// UV coordinates of vertex\nvarying vec3 vNormal;							// vertex normal\nvarying vec3 vWorldPosition;					// vertex world position\nvarying vec3 vViewPosition;						// vertex view position (flipped)\n\n\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vec3 normal = normalize(vNormal);\n	vec3 viewPosition = normalize(vViewPosition);\n\n    gl_FragColor.xyz = designColor.xyz;\n	gl_FragColor.a   = 1.0;\n}\n\n";
MR.shaderSource["TemplateVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\nprecision highp float;\nprecision highp int;\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nvarying vec2 vUV;							// UV coordinates of vertex\nvarying vec3 vNormal;						// vertex normal\nvarying vec3 vWorldPosition;				// vertex world position\nvarying vec3 vViewPosition;					// vertex view position (flipped)\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vUV = uv;\n\n	vec3 transformedNormal = normalMatrix * normal;\n	vNormal = normalize(transformedNormal);\n\n	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n	vWorldPosition = worldPosition.xyz;\n\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vViewPosition = -mvPosition.xyz;\n\n	gl_Position = projectionMatrix * mvPosition;\n}\n";
