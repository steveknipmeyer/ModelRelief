// ------------------------------------------------------------------------//// ModelRelief                                                             ////                                                                         //// Copyright (c) <2012-2017> Steve Knipmeyer                               //// ------------------------------------------------------------------------//var MR;MR = MR || {};MR.shaderSource = MR.shaderSource || {}; MR.shaderSource["DepthBufferFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n// enable extensions (e.g. dFdx, dFdy)\n#extension GL_OES_standard_derivatives : enable\n\n#include <packing>\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\nuniform vec3        designColor;				// color\nuniform float       cameraNear;                 // near clipping plane\nuniform float       cameraFar;                  // far clipping plane\nuniform sampler2D   tDiffuse;                   // diffuse texture (not used)\nuniform sampler2D   tDepth;                     // depth texture\n\nvarying vec2 vUV;								// UV coordinates of vertex\nvarying vec3 vNormal;							// vertex normal\nvarying vec3 vWorldPosition;					// vertex world position\nvarying vec3 vViewPosition;						// vertex view position (flipped)\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\n/// <summary>\n///  Read depth from buffer.\n//   Adjusts back to world (orthographic) coordinates.\n/// </summary>\nfloat readDepth (sampler2D depthSampler, vec2 uvCoordinate) {\n\n    float fragCoordZ = texture2D(depthSampler, uvCoordinate).x;\n    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\n    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n}\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vec3 normal = normalize(vNormal);\n	vec3 viewPosition = normalize(vViewPosition);\n\n    vec3 diffuse = texture2D(tDiffuse, vUV).rgb;\n    float depth = readDepth(tDepth, vUV);\n\n    gl_FragColor.rgb = vec3(depth);\n    gl_FragColor.a = 1.0;\n}\n\n";
MR.shaderSource["DepthBufferVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\nprecision highp float;\nprecision highp int;\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nvarying vec2 vUV;							// UV coordinates of vertex\nvarying vec3 vNormal;						// vertex normal\nvarying vec3 vWorldPosition;				// vertex world position\nvarying vec3 vViewPosition;					// vertex view position (flipped)\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vUV = uv;\n\n	vec3 transformedNormal = normalMatrix * normal;\n	vNormal = normalize(transformedNormal);\n\n	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n	vWorldPosition = worldPosition.xyz;\n\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vViewPosition = -mvPosition.xyz;\n\n	gl_Position = projectionMatrix * mvPosition;\n}\n";
MR.shaderSource["TemplateFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n#include <packing>\n\n// enable extensions (e.g. dFdx, dFdy)\n#extension GL_OES_standard_derivatives : enable\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\nuniform vec3        designColor;				// color\nuniform sampler2D   tDiffuse;                   // diffuse texture (not used)\nuniform sampler2D   tDepth;                     // depth texture\nuniform float       cameraNear;                 // near clipping plane\nuniform float       cameraFar;                  // far clipping plane\n\nvarying vec2 vUV;								// UV coordinates of vertex\nvarying vec3 vNormal;							// vertex normal\nvarying vec3 vWorldPosition;					// vertex world position\nvarying vec3 vViewPosition;						// vertex view position (flipped)\n\n\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vec3 normal = normalize(vNormal);\n	vec3 viewPosition = normalize(vViewPosition);\n\n    gl_FragColor.xyz = designColor.xyz;\n	gl_FragColor.a   = 1.0;\n}\n\n";
MR.shaderSource["TemplateVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\nprecision highp float;\nprecision highp int;\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nvarying vec2 vUV;							// UV coordinates of vertex\nvarying vec3 vNormal;						// vertex normal\nvarying vec3 vWorldPosition;				// vertex world position\nvarying vec3 vViewPosition;					// vertex view position (flipped)\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vUV = uv;\n\n	vec3 transformedNormal = normalMatrix * normal;\n	vNormal = normalize(transformedNormal);\n\n	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n	vWorldPosition = worldPosition.xyz;\n\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vViewPosition = -mvPosition.xyz;\n\n	gl_Position = projectionMatrix * mvPosition;\n}\n";
