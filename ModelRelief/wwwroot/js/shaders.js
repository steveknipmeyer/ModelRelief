// ------------------------------------------------------------------------//
// ModelRelief                                                             //
//                                                                         //
// Copyright (c) <2012-2017> Steve Knipmeyer                               //
// ------------------------------------------------------------------------//
var MR;
MR = MR || {};
MR.shaderSource = MR.shaderSource || {}; 

MR.shaderSource["DepthMapFragmentShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\n\n// THREE.js pre-defined fragment shader uniforms and attributes\n#if defined(NOOP)\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#endif\n\n// enable extensions (e.g. dFdx, dFdy)\n#extension GL_OES_standard_derivatives : enable\n\nuniform sampler2D   designTexture;				// texture map (DesignMaterial)\nuniform vec3        designColor;				// enamel color\nuniform sampler2D   tMatCap;					// SEM reflection map\n\nvarying vec2 vUV;								// UV coordinates of vertex\nvarying vec3 vNormal;							// vertex normal\nvarying vec3 vWorldPosition;					// vertex world position\nvarying vec3 vViewPosition;						// vertex view position (flipped)\n\nconst vec3 noColor = vec3(0.0, 0.0, 0.0);\n\nfloat bumpScale = -0.5; \n\nfloat opacity = 1.0;\nvec3  emissive = vec3(0.0, 0.0, 0.0);\n\nfloat shininess = 0.5;\n\nfloat specularStrength = 1.0;\nvec3  specular = vec3(1.0, 1.0, 1.0);\n\nvec3 ambient = vec3(0.1, 0.1, 0.1);\nvec3 ambientLightColor = vec3(1.0, 1.0, 1.0);\n\nconst int LightCount = 3;\nvec3 directionalLightColor[3];\nvec3 directionalLightDirection[3];\n\n// ------------------------------------------------------------------------// \n// Bump Maps															   //\n// ------------------------------------------------------------------------//\n// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html \n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n/// <summary>\n///  Derivative\n/// </summary>\nvec2 dHdxy_fwd() {\n\n	vec2 dSTdx = dFdx(vUV);\n	vec2 dSTdy = dFdy(vUV);\n\n#define ORIGINAL 1\n\n#if defined (ALPHA)	\n	float HllComponent = texture2D(designTexture, vUV).a;\n	float dBxComponent = texture2D(designTexture, vUV + dSTdx).a;\n	float dByComponent = texture2D(designTexture, vUV + dSTdy).a;\n\n	float Hll = bumpScale * HllComponent;\n	float dBx = bumpScale * dBxComponent - HllComponent;\n	float dBy = bumpScale * dByComponent - HllComponent;\n#endif\n\n#if defined (COLOR)	\n	vec3 HllColor = texture2D(designTexture, vUV).rgb;\n	vec3 dBxColor = texture2D(designTexture, vUV + dSTdx).rgb;\n	vec3 dByColor = texture2D(designTexture, vUV + dSTdy).rgb;\n\n	float HllComponent = any(greaterThan(HllColor, noColor)) ? 255.0 : 0.0;\n	float dBxComponent = any(greaterThan(dBxColor, noColor)) ? 255.0 : 0.0;\n	float dByComponent = any(greaterThan(dByColor, noColor)) ? 255.0 : 0.0;\n\n	float Hll = bumpScale * HllComponent;\n	float dBx = bumpScale * dBxComponent - HllComponent;\n	float dBy = bumpScale * dByComponent - HllComponent;\n#endif\n\n#if defined (ORIGINAL)\n	float Hll = bumpScale * texture2D(designTexture, vUV).x;\n	float dBx = bumpScale * texture2D(designTexture, vUV + dSTdx).x - Hll;\n	float dBy = bumpScale * texture2D(designTexture, vUV + dSTdy).x - Hll;\n#endif\n\n	return vec2(dBx, dBy);\n}\n\n/// <summary>\n///  Bump map normal\n/// </summary>\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n	vec3 vSigmaX = dFdx(surf_pos);\n	vec3 vSigmaY = dFdy(surf_pos);\n	vec3 vN = surf_norm;			// normalized\n\n	vec3 R1 = cross(vSigmaY, vN);\n	vec3 R2 = cross(vN, vSigmaX);\n\n	float fDet = dot(vSigmaX, R1);\n\n	vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n	return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n/// <summary>\n///  Define the scene lighting.\n/// </summary>\nvoid setupLighting() {\n\n	directionalLightColor[0] = vec3(1.0, 1.0, 1.0);\n	directionalLightColor[1] = vec3(1.0, 1.0, 1.0);\n	directionalLightColor[2] = vec3(1.0, 1.0, 1.0);\n\n	directionalLightDirection[0] = vec3(  0.0,  30.0, 30.0);\n	directionalLightDirection[1] = vec3( 30.0, -10.0,  30.0); \n	directionalLightDirection[2] = vec3(-30.0, -10.0,  30.0);\n}\n\n/// <summary>\n///  Returns whether a design texture is defined.\n///  if false, the body is being rendered.\n/// </summary>\nbool designTextureValid() {\n\n	return (noColor != designColor);\n}\n\n/// <summary>\n///  Look up the environment color.\n/// </summary>\nvec3 calculateEnvironmentColor() {\n\n	// SEM: Spherical Environment Mapping\n	vec3 e = normalize(-vViewPosition.xyz);\n\n	vec3  r = reflect(e, vNormal);\n	float m = 2.0 * sqrt(pow(r.x, 2.0) + pow(r.y, 2.0) + pow(r.z + 1.0, 2.0));\n	vec2 uvSEM = r.xy / m + 0.5;\n\n	vec3 environmentColor = texture2D(tMatCap, uvSEM).rgb;\n	\n	return environmentColor;\n}\n\n/// <summary>\n///  Compute the blended color based on the environment map and the design texture.\n/// </summary>\nvec3 calculateBlendedColor() {\n	\n	// SEM\n	vec3 environmentColor = calculateEnvironmentColor ();\n\n	if (vec3(0.0) == designColor)\n		return environmentColor;\n\n	float  minimumAlpha = 0.0;\n	float  maximumAlpha = 0.8;				// < 1.0; necessary to blend a component of the reflection map into the enamel color\n\n	// calculate alpha component from designTexture\n	float textureAlpha = texture2D(designTexture, vUV).a;\n	float blendFactor = (textureAlpha == 0.0) ? 0.0 : clamp(textureAlpha, minimumAlpha, maximumAlpha);\n          \n          // WIP\n          blendFactor = 0.4;\n\n	// blend environment map with designColor \n	vec3 textureColor = texture2D(designTexture, vUV).rgb;\n	vec3 blendedColor = (designColor.rgb * blendFactor) + (environmentColor * (1.0 - blendFactor));\n\n	return blendedColor;\n}\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	setupLighting();\n\n	vec3 normal = normalize(vNormal);\n	vec3 viewPosition = normalize(vViewPosition);\n\n	// bump map\n	if (designTextureValid())\n  		normal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd());\n\n	// base color\n	vec3 blendedColor = calculateBlendedColor();\n\n	vec3 directionalDiffuse  = vec3(0.0);\n	vec3 directionalSpecular = vec3(0.0);\n	for (int iLight = 0; iLight < LightCount; iLight++) {\n\n		vec4 lightDirection = viewMatrix * vec4(directionalLightDirection[iLight], 0.0);\n		vec3 directionalVector = normalize(lightDirection.xyz);\n\n		// diffuse\n		float dotProduct = dot(normal, directionalVector);\n\n		float directionalDiffuseWeight = max(dotProduct, 0.0);\n		directionalDiffuse += blendedColor * directionalLightColor[iLight] * directionalDiffuseWeight;\n\n		// specular\n		vec3 directionalHalfVector = normalize(directionalVector + viewPosition);\n		float directionalDotNormalHalf = max(dot(normal, directionalHalfVector), 0.0);\n		float directionalSpecularWeight = specularStrength * max(pow(directionalDotNormalHalf, shininess), 0.0);\n\n		float specularNormalization = (shininess + 2.0) / 8.0;\n		vec3 schlick = specular + vec3(1.0 - specular) * pow(max(1.0 - dot(directionalVector, directionalHalfVector), 0.0), 5.0);\n		directionalSpecular += schlick * directionalLightColor[iLight] * directionalSpecularWeight * directionalDiffuseWeight * specularNormalization;\n	}\n\n	vec3 totalDiffuse  = vec3(0.0);\n	vec3 totalSpecular = vec3(0.0);\n\n	totalDiffuse  += directionalDiffuse;\n	totalSpecular += directionalSpecular;\n\n	gl_FragColor.xyz = blendedColor.xyz * (emissive + totalDiffuse + ambientLightColor * ambient) + totalSpecular;\n	gl_FragColor.a   = 1.0;\n}\n\n";
MR.shaderSource["DepthMapVertexShader"] = "// ------------------------------------------------------------------------//\n// ModelRelief                                                             //\n//                                                                         //\n// Copyright (c) <2012-2017> Steve Knipmeyer                               //\n// ------------------------------------------------------------------------//\nprecision highp float;\nprecision highp int;\n\n// THREE.js pre-defined vertex shader uniforms and attributes\n// http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram\n#if defined(NOOP)\nuniform mat4 modelMatrix;					// = object.matrixWorld\nuniform mat4 modelViewMatrix;				// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 projectionMatrix;				// = camera.projectionMatrix\nuniform mat4 viewMatrix;					// = camera.matrixWorldInverse\nuniform mat3 normalMatrix;					// = inverse transpose of modelViewMatrix\nuniform vec3 cameraPosition;				// = camera position in world space\n\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#endif\n\nvarying vec2 vUV;							// UV coordinates of vertex\nvarying vec3 vNormal;						// vertex normal\nvarying vec3 vWorldPosition;				// vertex world position\nvarying vec3 vViewPosition;					// vertex view position (flipped)\n\n/// <summary>\n///  Main entry point\n/// </summary>\nvoid main() {\n\n	vUV = uv;\n\n	vec3 transformedNormal = normalMatrix * normal;\n	vNormal = normalize(transformedNormal);\n\n	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n	vWorldPosition = worldPosition.xyz;\n\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vViewPosition = -mvPosition.xyz;\n\n	gl_Position = projectionMatrix * mvPosition;\n}\n";
